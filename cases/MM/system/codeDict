/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  v2012                                 |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version         2.0;
    format          ascii;
    class           dictionary;
    object          codeDict;
}

erosionFlux
{
    // code
    // \left.\left(\frac{\partial \phi}{\partial z}\right)\right|_{\text {surface}} 
    // = -\frac{1}{D_{t}} \frac{\left|M_{\text {ero }}\right|}{A_{\mathrm{hol}}}
    code
    #{
        // 获得当前Patch的ID
        label patchIndex = patch().index();

        const scalar rhod = 917.;

        fvPatchField<scalar> Q
        (
            patch().lookupPatchField<volScalarField, scalar>("alpha.snow")
        );
        
        // 湍流黏度
        const fvPatchField<scalar>& nut
        (
            patch().lookupPatchField<volScalarField, scalar>("nut")
        );

        const fvPatchField<vector>& ssp
        (
            patch().lookupPatchField<volVectorField, vector>("myWallShearStress")
        );

        // 获得与边界面相邻网格格心处的雪漂浓度
        const tmp<scalarField> &QInt = patch().lookupPatchField<volScalarField, scalar>("alpha.snow").patchInternalField();

        scalar averageGrad = 0.;
        forAll(Q, i)
        {
            scalar uShear = sqrt(mag(ssp[i]));

            // Info << uShear << endl;
            
            scalar Uthreshold = 0.27;

            scalar zGrad;
            if (uShear > Uthreshold) // 侵蚀
            {
                zGrad = -7e-4 * (sqr(uShear) - sqr(Uthreshold)) / (nut[i] + 1e-8);
            }
            else // 沉积
            {
                zGrad = 0.;  //发生沉积时梯度为0
            }

            averageGrad += zGrad;
            
            Q[i] = QInt()[i] - zGrad / patch().deltaCoeffs()[i] / rhod;
        }

        Info << "Average grad: " << averageGrad / Q.size() << endl;

        operator == (Q);

        //Info << "done." <<endl;
    #};
        
    // Optional
    codeInclude
    #{
        #include "fvCFD.H"
        #include "turbulentTransportModel.H"
    #};

    // Optional
    codeOptions 
    #{
        -I$(LIB_SRC)/finiteVolume/lnInclude \
        -I$(LIB_SRC)/meshTools/lnInclude \
        -I$(LIB_SRC)/TurbulenceModels/turbulenceModels/lnInclude \
        -I$(LIB_SRC)/TurbulenceModels/incompressible/lnInclude \
        -I$(LIB_SRC)/transportModels \
        -I$(LIB_SRC)/transportModels/incompressible/singlePhaseTransportModel
    #};
}
